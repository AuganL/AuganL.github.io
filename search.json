[{"title":"JavaScript定时器","url":"/2022/12/15/JavaScript%E5%AE%9A%E6%97%B6%E5%99%A8/","content":"setTimeout（）\n有时候我们希望编写的JavaScript代码函数可以延时执行\n这时候我们就可以使用setTimeout指定一个回调函数并指定希望它稍后运行的时间（单位：毫秒）\n\n\n直接在函数参数内定义回调函数\n\nsetTimeout(()=&gt;&#123;\t\t...  //该函数2秒后执行&#125;,2000)\n\n\n定义一个函数，作为参数传人setTimeout内\n\nconst  Fn = (firstParam, secondParam) =&gt; &#123;\t...&#125;setTimeout(Fn ,2000, firstParam, secondParam)  //向Fn内传入参数\n\n\nsetTimeout的返回值是定时器的id\n\nsetInterval（）\nsetInterval是一个类似于setTimeout的函数，不同的是：setInterval会在指定的时间间隔内一直运行回调函数，而不是运行一次\n\nsetInterval (() =&gt; &#123;\t\t...  //每两秒运行一次&#125;，2000)\n\n\n使用setInterval设置了在规定的时间间隔执行回调函数的时候，如果我们需要对其执行停止的操作，可以使用clearInterval\n\nconst id = setInterval (() =&gt; &#123;\t\t... &#125;,2000)//......clearInterval(id)\n\n\n通常在 setInterval 回调函数中调用 clearInterval，以使其自行判断是否应该再次运行或停止。 例如，此代码会运行某些事情，除非 App.somethingIWait 具有值 arrived\n\nconst interval = setInterval(() =&gt; &#123;  if (App.somethingIWait === &#x27;arrived&#x27;) &#123;    clearInterval(interval)    return  &#125;  // 否则做些事情&#125;, 100)\n","categories":["前端","JavaScript"],"tags":["前端","JavaScript","setTimeout","定时器"]},{"title":"JavaScript的事件循环机制","url":"/2022/12/15/JavaScript%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E6%9C%BA%E5%88%B6/","content":"\n首先，JavaScript是单线程解释性的语言，那么在执行一段js程序的时候，当遇到异步任务&#x2F;耗时任务，那么这段程序就停下来等待耗时任务执行完成后再继续执行后续的程序，那么就会造成阻塞等待的问题。\n所以JavaScript引入了事件循环机制来处理这一问题\nJavaScript讲一段程序中的任务分为同步任务和异步任务\n当一段JavaScript程序被执行的时候，会将同步任务放入主线程形成一个执行栈，当遇到异步任务的时候，则将异步任务放入等待队列，等待同步任务的执行栈执行完再执行等待队列中的异步任务，如此进行循环，就被称为事件循环机制\n事件队列\n\n\n对于一段JavaScript程序，会存在同步任务和异步任务，由于JavaScript是单线程的，则会在执行到异步任务的时候，会发生阻塞进程，等待异步任务执行完成后再执行后续的程序，为了解决这一问题，引入了事件循环机制，也就是，执行一段JavaScript程序的时候，将同步任务放入主线程中形成一个执行栈，将异步任务放入等待队列，当一个同步任务的执行栈执行完后，在对该同步任务的异步任务执行，如此的一个循环过程，就被称为事件循环。\n对于异步任务，被分为宏任务和微任务，宏任务是由浏览器规定的，微任务是由es6语法规定的。\n一般会先执行微任务然后再执行宏任务\n宏任务包括：\n\nscript全部代码\nsetTimeout\nsetInterval\najax\ndom事件\n&#96;&#96;setImmediate&#96;（浏览器暂时不支持，只有IE10支持）\nI/O \nUI Rendering\n\n微任务包括：\n\npromise\nasync\nawait\n\n\n","categories":["前端","JavaScript"],"tags":["前端","JavaScript","浏览器","事件循环"]},{"title":"Token一些特性","url":"/2022/12/15/Token%E4%B8%80%E4%BA%9B%E7%89%B9%E6%80%A7/","content":"什么是Tokentoken是多用户处理认证的最佳方式\ntoken的特性\n无状态、可扩展\n支持移动设备\n跨程序调用\n安全\n\n基于Token的身份验证的过程\n用户通过用户名和密码发送请求。\n\n程序验证。\n\n程序返回一个签名的token 给客户端。\n\n客户端储存token,并且每次用于每次发送请求。\n\n服务端验证token并返回数据。\n\n\n 每一次请求都需要token。token应该在HTTP的头部发送从而保证了Http请求无状态。我们同样通过设置服务器属性Access-Control-Allow-Origin:* ，让服务器能接受到来自所有域的请求。需要主要的是，在ACAO头部标明(designating)*时，不得带有像HTTP认证，客户端SSL证书和cookies的证书。\n","categories":["前端","浏览器"],"tags":["前端","浏览器","token","网络相关"]},{"title":"localStorage和sessionStorage的区别","url":"/2022/12/15/localStorage%E5%92%8CsessionStorage%E7%9A%84%E5%8C%BA%E5%88%AB/","content":"localStorage和sessionStorage的区别\nlocalStorage和sessionStorage都是游览器用来存储客户端临时信息的对象\n两者都只能存储字符串类型的对象\n在生命周期方面：\nlocalStorage是永久的，除非用户自己清除，否则localStorage的数据会一直存储在浏览器当中\nsessionStorage的生命周期取决于当前窗口或者标签页，一旦窗口或者标签页被关闭，对应的sessionStorage也会被清空\n\n\n共享方面：\nlocalStorage在不同页面同一个浏览器下，是可以共享的\nsessionStorage在不同页面下不能共享，除非属于同一个顶级窗口即同源页面。\n\n\n\nTCP三次握手\n首先我们知道，tcp是面相连接的。当某一方向另一方发送数据之前都必须在双方宅男建立tcp连接。\ntcp连接是通过三次握手进行初始化的\n三次握手的目的就是为了同步对方的序列号和确认号。\n过程：\n第一次握手：建立连接。客户端发送连接请求报文段，将SYN位置为1，Sequence Number为x;然后，客户端进入SYN_SEND状态，等待服务器的确认;\n第二次握手：服务器收到SYN报文段。服务器收到客户端的SYN报文段，需要对这个SYN报文段进行确认，设置Acknowledgment Number为x+1(Sequence Number+1);同时，自己自己还要发送SYN请求信息，将SYN位置为1，Sequence Number为y;服务器端将上述所有信息放到一个报文段(即SYN+ACK报文段)中，一并发送给客户端，此时服务器进入SYN_RECV状态;\n第三次握手：客户端收到服务器的SYN+ACK报文段。然后将Acknowledgment Number设置为y+1，向服务器发送ACK报文段，这个报文段发送完毕以后，客户端和服务器端都进入ESTABLISHED状态，完成TCP三次握手。\n\n\n\nTCP四次挥手可以被优化当服务器没有数据要发送给客户端的时候，tcp的四次挥手会被优化为三次\nTCP三次握手的目的为了防止生效的连接请求报文被服务端接受\n为什么TCP握手不用两次如果只有两次握手，假设当客户端发送第一次连接请求由于网络拥塞的原因，迟迟未到服务端，客户端没接收到确认报文，认为服务端没有收到，于是重新发送请求报文并与服务端建立连接，等这次连接断开了，之前滞留的那个请求报文又到达了服务端，就会让服务端与客户端再次连接成功，这时服务端就会一直等待客户端发送请求，造成了资源的浪费。\n","categories":["前端","浏览器"],"tags":["前端","浏览器"]},{"title":"React","url":"/2022/12/15/react/","content":"Hello React\n通过create-react-app创建一个react项目\n\n下面我们删除src下的所有文件，然后创建一个index.js文件（默认必须使用index命名）\n\n接下来我们需要在index.js文件内引入react、react-dom这两个模块，然后调用react-dom的render方法创建react组件并渲染到指定的页面dom节点上\n/** *      引入react，因为在react项目中需要用到react的一种语法----JSX ---- js+xml *      引入react-dom，该模块可以帮助我们将react组件渲染到页面上 *      通过调用react-dom模块的render方法实现将react组件渲染并构建dom树，然后将该组件插入到指定的元素上 *      ReactDom.render()       --该方法两个参数：   *                                              第一个参数就是要被插入的内容 *                                              第二个参数就是选择被插入的元素 */import React from &#x27;react&#x27;;import ReactDom from &#x27;react-dom&#x27;;    ReactDom.render(        &lt;h1&gt;hello react&lt;/h1&gt;,        document.getElementById(&#x27;root&#x27;)    )\n\nJSX语法与组件\nJSX语法实现了将HTML和JavaScript混合，然后通过编译器将HTML转换到JavaScript当中去，最后由浏览器执行。\n编译过程由Babel的jsx编译器实现\nReact使用JSX来代替常规的JavaScript\nJSX是一个看起来像xml的JavaScript语法控制，在React中会被Babel编译为JavaScript\n\nJSX编写格式\nReact的JSX是使用大写小写来区分本地组件和html组件的\n在React的JSX中编写html的时候，对于标签内的for、class、style这三个属性存在区别，需要写为htmlFor、className、style等号后需要使用双花括号表示\n\nimport React, &#123; Component &#125; from &#x27;react&#x27;var MyImg = require(&#x27;./assets/01.jpg&#x27;)export default class App2 extends Component &#123;    render() &#123;        return (            &lt;&gt;          \t\t\t&lt;!--注意这里的htmlFor  className   style=&#123;&#123;...&#125;&#125; src=&#123;&#123;&#125;&#125; --&gt;                &lt;label htmlFor=&quot;ipt&quot;&gt;label&lt;/label&gt;                &lt;input type=&quot;text&quot; id=&quot;ipt&quot; className=&quot;ipt&quot; style=&#123;&#123;background: &#x27;pink&#x27;, color: &#x27;green&#x27;&#125;&#125; /&gt;                &lt;hr/&gt;                &lt;img src=&#123;MyImg&#125; alt=&quot;&quot;/&gt;            &lt;/&gt;        )    &#125;&#125;\n\n\n\nJSX原理原理：对于jsx，在编译过程中会将我们在render方法的第一个参数中编写的HTML的dom块转换为用js的表示，也就是通过调用React.createElement（）去实现对dom树的修改。\n\n可以对比一下以下两段代码，能明白了。（需要注意的是，以下这两段代码都是可以正常运行且效果是一样的，只是我们一般直接写html即可）\nReactDom.render(     &lt;div id=&#x27;reactDiv&#x27; class=&#x27;elMM&#x27;&gt;         hello react     &lt;/div&gt;,     document.getElementById(&#x27;root&#x27;) )\n\nReactDom.render(  React.createElement(      &quot;div&quot;,              &#123;             id:&quot;reactDiv&quot;,             class:&quot;MM&quot;         &#125;,         &quot;hello react&quot;     ),     document.getElementById(&#x27;root&#x27;) )\n\nJSX编译流程\n使用React构建Dom组件\nBabel对其进行编译，将jsx文件编译为js对象\n然后运行该js，调用到render的方法去将Dom组件插入到页面中\n\nClass组件\n通过在src下创建js文件并在该文件内使用class声明一个组件类(该组件需要基础React.Component)，然后通过重写父类的render方法来返回一个组件模板，最后使用export default导出该组件。\n然后在需要用到该组件的js文件内导入该文件，并使用render方法将该组件渲染到页面的DOM树上。\n\n\n创建组件\nimport  React from &#x27;react&#x27;export default class App extends React.Component&#123;    render()&#123;        return &lt;div&gt;class Component &lt;/div&gt;    &#125;&#125;\n\n引入组件并使用\nimport React from &#x27;react&#x27;;import ReactDom from &#x27;react-dom&#x27;;import App from&#x27;./Component/app.js&#x27;    ReactDom.render(        &lt;App/&gt;,        document.getElementById(&#x27;root&#x27;)    )\n\n\n注意：\n\n\n定义组件的时候，return后面只能有一个根标签。\n使用组件的时候，首字母必须大写\n如果定义组件的时候最外层根标签不想使用div，可以使用&lt;&gt;&lt;&#x2F;&gt;代替\n\n函数式组件函数式组件顾名思义就是，通过函数来讲html块返回。\nexport default function hello()&#123;    return (        &lt;div style=&#123;&#123;color:&#x27;blue&#x27;&#125;&#125;&gt;            函数式组件hello        &lt;/div&gt;    )&#125;\n\n同样的，我们只需要在使用这个组件的js文件内引入该组件使用即可。如下 \nimport React from &#x27;react&#x27;;import ReactDom from &#x27;react-dom&#x27;;import Hello from &#x27;./Methor-Component/hello.js&#x27;    ReactDom.render(        &lt;div&gt;            &lt;Hello&gt;&lt;/Hello&gt;        &lt;/div&gt;,        document.getElementById(&#x27;root&#x27;)    )\n\n组件的样式行内样式首先我们需要知道的是，如果在jsx的html模板中使用行内样式的话，赋予style的应该是一个对象形式的模板值。\n\n写法一\nexport default function hello()&#123;    return (        &lt;div style=&#123;&#123;color:&#x27;blue&#x27;&#125;&#125;&gt;            函数式组件hello        &lt;/div&gt;    )&#125;\n\n写法二\nexport default function hello()&#123;  let obj=&#123;    color:&#x27;blue&#x27;  &#125;    return (        &lt;div style=&#123;obj&#125;&gt;            函数式组件hello        &lt;/div&gt;    )&#125;\n\n\n需要注意的是：如果我们使用到的样式属性是例如background-color这种形式的，我们在jsx中必须使用驼峰命名的方式书写，如下\nexport default function hello()&#123; //定义变量 let name=&#x27;函数式组件hello&#x27; let obj=&#123;     //注意这里--修改为驼峰命名法的方式     backgroundColor:&#x27;blue&#x27;\t &#125; return (     &lt;div style=&#123;obj&#125;&gt;         name=&#123;name&#125;     \t&#123;/*注意这里--修改为驼峰命名法的方式 */&#125;         &lt;div style=&#123;&#123;backgroundColor:&#x27;red&#x27;&#125;&#125;&gt;&lt;/div&gt;     &lt;/div&gt; )&#125;\n\n外部样式为组件编写外部css样式文件之后，我们只需要在对应的组件js文件中import对应的css文件即可![截屏2022-03-19 下午9.28.36](data:image&#x2F;svg+xml,)\n事件绑定在节点标签内定义函数\n例如我们对div块绑定点击事件—-onClick&#x3D;{()&#x3D;&gt;{…..}}\n\n在class组件内\n如果在指定事件函数的时候打上括号，那么在页面在加载的时候该函数会被自动执行\n\nreact事件绑定与普通的事件绑定的区别\nreact并不会把事件真正绑定到具体的节点上，而是采用事件代理的方法\n\n关于ES6改变this指向\ncall\napply\nbind\n\ncall改变this指向并自动执行对应的函数\nvar obj1=&#123;\tname=&#x27;obj1&#x27;,\tgetname()&#123;\t\t\tconsole.log(this.name)\t&#125;&#125;var obj2=&#123;\tname=&#x27;obj2&#x27;,\tgetname()&#123;\t\t\tconsole.log(this.name)\t&#125;&#125;obj1.getname().call(obj2)\t\t//控制台输出的是obj2\n\n\n\napply改变this指向并自动执行对应的函数\nvar obj1=&#123;\tname=&#x27;obj1&#x27;,\tgetname()&#123;\t\t\tconsole.log(this.name)\t&#125;&#125;var obj2=&#123;\tname=&#x27;obj2&#x27;,\tgetname()&#123;\t\t\tconsole.log(this.name)\t&#125;&#125;obj1.getname().apply(obj2)\t\t//控制台输出的是obj2\n\nbind\n改变this指向，当不会自动执行，如果需要自动执行，则需要在后面加一个括号\nobj2.getname().bind(obj1)()\n\nRef的应用通过ref获取节点元素信息\n通过给标签设置ref，然后通过this.refs.username,就可以获取对应节点元素ref对象\n\n\n设置input的ref为inputRef，然后通过调用this.refs.inputRef.value就可以获取到input框的内容了\n\nimport React, &#123; Component &#125; from &#x27;react&#x27;export default class REF extends Component &#123;    render() &#123;        return (            &lt;div&gt;                &lt;input ref=&#x27;inputRef&#x27; /&gt;                &lt;button onClick=&#123; ()=&gt;&#123; this.getInputData() &#125; &#125; &gt;获取input&lt;/button&gt;            &lt;/div&gt;        )    &#125;    getInputData()&#123;        //通过给input设置ref，然后调用refs中对应的ref就可以获取到input框的ref对象        console.log(this.refs.inputRef.value);    &#125;&#125;\n\n采用react.createRef()创建ref对象由于在this.ref存在被弃用的问题，所以react为我们通过了createRef方法去创建ref对象，创建之后我们只需要在对应的节点标签中设置ref的时候引用该对应，即可将该ref对象指向该节点，然后我们就可以通过调用该对象去获取对应节点的ref信息\nimport React, &#123; Component &#125; from &#x27;react&#x27;export default class CreateRef extends Component &#123;    //通过react创建一个ref对象，然后只需要在对应的节点标签设置ref的时候引用这个对象，即可通过该ref对象去获取对应节点的信息    input = React.createRef()    render() &#123;        return (            &lt;div&gt;            &#123;/* 设置input的ref对象为input */&#125;                &lt;input ref=&#123;this.input&#125; /&gt;                &lt;button onClick=&#123;()=&gt;&#123; this.getInput()&#125;&#125; &gt;获取input&lt;/button&gt;            &lt;/div&gt;        )    &#125;    getInput()&#123;      \t//获取input的值        console.log(this.input.current.value);    &#125;&#125;\n\n组件数据挂载方式状态（state）什么是状态state\n状态state是组件内部一组特有的数据，以一个对象形式存在。\n状态存放了该组件用于渲染的数据\n状态还承担着管理该组件被渲染数据的功能\n可以通过state去把变量绑定在组件内部，也可以通过setstate方法去对状态内的数据变量进行修改从而在组件上渲染响应\n\n定义state在class组件内直接声明stateimport React, &#123; Component &#125; from &#x27;react&#x27;export default class StateTest extends Component &#123;    constructor()&#123;        state:&#123;        \t\tname:&#x27;stateComName&#x27;        &#125;        render() &#123;            return (                &lt;div&gt;                &#123;/* 点击按钮，修改状态state */&#125;                    &lt;button onClick=&#123;()=&gt;&#123;                        this.setState(&#123;name:&#x27;upData&#x27;&#125;)                    &#125;&#125;&gt;                        up                    &lt;/button&gt;                &#123;/* 渲染state内的name到页面上 */&#125;                    &#123;this.state.name&#125;                &lt;/div&gt;            )        &#125;&#125;\n\n通过构造方法声明import React, &#123; Component &#125; from &#x27;react&#x27;export default class StateTest extends Component &#123;    constructor()&#123;        super()      //创建state        this.state=&#123;           \tname:&#x27;stateComName&#x27;        &#125;    &#125;    render() &#123;        return (            &lt;div&gt;            &#123;/* 点击按钮，修改状态state */&#125;                &lt;button onClick=&#123;()=&gt;&#123;                    this.setState(&#123;name:&#x27;upData&#x27;&#125;)                &#125;&#125;&gt;                    up                &lt;/button&gt;            &#123;/* 渲染state内的name到页面上 */&#125;                &#123;this.state.name&#125;            &lt;/div&gt;        )    &#125;&#125;\n\n修改state内的数据变量\n通过调用state的setState方法对state内的数据变量修改并通知react重新渲染被修改的数据变量\n\nimport React, &#123; Component &#125; from &#x27;react&#x27;export default class StateTest extends Component &#123;    constructor()&#123;        super()      //创建state        this.state=&#123;           \tname:&#x27;stateComName&#x27;        &#125;    &#125;    render() &#123;        return (            &lt;div&gt;            &#123;/* 点击按钮，修改状态state */&#125;                &lt;button onClick=&#123;()=&gt;&#123;                    this.setState(&#123;name:&#x27;upData&#x27;&#125;)                &#125;&#125;&gt;                    up                &lt;/button&gt;            &#123;/* 渲染state内的name到页面上 */&#125;                &#123;this.state.name&#125;            &lt;/div&gt;        )    &#125;&#125;\n\nsetState是异步的![截屏2022-03-22 下午3.24.37](data:image&#x2F;svg+xml,)\n如果setState的调用处于一个异步逻辑，则会变成同步如果setState的调用处于一个同步逻辑，则会变成异步setState的第二个参数–回调函数\n当setState中对于state修改操作的异步执行之后，就会调用该第二个参数的回调函数\n\nthis.setState(&#123;\t\t.....      &#125;,()=&#123;          console.log(&#x27;回调函数&#x27;)      &#125;)\n\n函数式组件内的state//引入userState模块import React,&#123; useState &#125; from &#x27;react&#x27;export default function Hooks() &#123;  //创建num的state，nun=0    const [num,setNum] =useState(0)    return (        &lt;div&gt;            &#123;num&#125;            &lt;button onClick=&#123;()=&gt;setNum(num+1)&#125;&gt;                click            &lt;/button&gt;        &lt;/div&gt;           )&#125;\n\n列表渲染React中实现列表渲染，与vue不同的是，vue是直接使用v-for的指令去循环遍历一个数组然后动态的在dom上创建节点元素。而React则是通过调用元素JavaScript中Array类型的map方法来实现。\n\n对于Array.map()方法：该方法是通过遍历调用该方法的Array然后，将遍历到的每一项都去执行作为参数传入到该map方法内的函数,最后返回执行结果\n\n也就是说，在React中通过调用Array的map方法去遍历list的每一项元素，然后通过我们的需要将创建html模板的函数作为参数传到map方法中，最后返回对应的html模板，从而实现对列表的循环然后渲染到页面上\nimport React, &#123; Component &#125; from &#x27;react&#x27;export default class StateTest extends Component &#123;    constructor()&#123;        super()      //创建state        this.state=&#123;           list:[1,2,3,4,5]        &#125;    &#125;    render() &#123;        return (            &lt;div&gt;            \t\t&lt;ul&gt;            \t\t\t\t&#123;                    \tthis.state.list.map(item =&gt; &lt;li&gt;&#123;item&#125;&lt;/li&gt;)                  \t&#125;            \t\t&lt;/ul&gt;            &lt;/div&gt;        )    &#125;&#125;\n\n添加key为被创建的每个节点添加key\nrender() &#123;       return (           &lt;div&gt;           \t\t&lt;ul&gt;           \t\t\t\t&#123;                   \tthis.state.list.map((item,index) =&gt; &lt;li key=&#123;index&#125;&gt;&#123;item&#125;&lt;/li&gt;)                 \t&#125;           \t\t&lt;/ul&gt;           &lt;/div&gt;       )   &#125;\n\n如果对array.map还是无法理解，可以执行以下的代码let array=[1,2,3,4,5,6]let mapArray = array.map(item =&gt; item*2 )console.log(mapArray)\t//[2,4,5,8,10,12]\n\n条件渲染通过三目运算符去实现\n这种方式就类似与vue的v-if指令，通过判断Ture or False来创建渲染节点 \n\nexport default class IFdemo extends Component &#123;    InputRef=React.createRef()    ModelDemo=`&lt;h1 &gt;条件为true&lt;/h1&gt;`    ModelDemox=`&lt;h1&gt;条件渲染为false&lt;/h1&gt;`     state=&#123;        data:&#x27;条件渲染&#x27;,        TF:true,            &#125;    render() &#123;        return (            &lt;div&gt;            &#123;/*通过判断输入框内数字的大小的条件去将ModelDemo与ModelDemox渲染到页面*/&#125;                &lt;input ref=&#123;this.InputRef&#125;&gt;&lt;/input&gt;                &lt;button onClick=&#123;()=&gt;this.check()&#125;&gt;识别&lt;/button&gt;               &#123;                   this.state.TF?&lt;div dangerouslySetInnerHTML=&#123;&#123;__html:this.ModelDemo&#125;&#125;&gt;&lt;/div&gt;:&lt;div dangerouslySetInnerHTML=&#123;&#123;__html:this.ModelDemox&#125;&#125;&gt;&lt;/div&gt;               &#125;            &lt;/div&gt;        )    &#125;    check()&#123;        if(this.InputRef.current.value&gt;10)&#123;            this.setState(&#123;                TF:true            &#125;)        &#125;else&#123;            this.setState(&#123;                TF:false            &#125;)        &#125;    &#125;&#125;\n\n通过控制hidden去实现\n这种方式就类似于vue的v-show指令，在页面加载的时候就会创建，只是判断ture or false决定是否显示\n\n.ShowClass&#123;    display: none;&#125;\n\nimport React, &#123; Component &#125; from &#x27;react&#x27;import &#x27;./Css/IfHidden.css&#x27;export default class IfHidden extends Component &#123;    InputRef=React.createRef()    ModelDemo=`&lt;h1 &gt;条件为true&lt;/h1&gt;`    state=&#123;        data:&#x27;条件渲染&#x27;,        TF:true,            &#125;    render() &#123;        return (            &lt;div&gt;                &lt;input ref=&#123;this.InputRef&#125;&gt;&lt;/input&gt;                &lt;button onClick=&#123;()=&gt;this.check()&#125;&gt;识别&lt;/button&gt;            &#123;/*            \t\t\t通过判断TF的值来决定是否将设置有display：none的class选择器设置在该div上            */&#125;                &lt;div className=&#123;this.state.TF?&#x27;&#x27;:&#x27;ShowClass&#x27;&#125;&gt;                    &lt;div dangerouslySetInnerHTML=&#123;&#123;                        __html:this.ModelDemo                    &#125;&#125;&gt;&lt;/div&gt;                &lt;/div&gt;            &lt;/div&gt;        )    &#125;    check()&#123;        if(this.InputRef.current.value&gt;10)&#123;            this.setState(&#123;                TF:true            &#125;)        &#125;else&#123;            this.setState(&#123;                TF:false            &#125;)        &#125;    &#125;&#125;\n\ndangerouslySetInnerHTML\ndangerouslySetInnerHTML作为标签的属性，设置__html属性来将指定的html代码快渲染到到页面中\n\nimport React, &#123; Component &#125; from &#x27;react&#x27;export default class dangerouslySetInnerHTML extends Component &#123;    InputRef=React.createRef()    ModelDemo=`&lt;div&gt;    \t\t\t\t\t\t\t&lt;h1&gt;插入模块&lt;/h1&gt;    \t\t\t\t\t&lt;/div&gt;`    render() &#123;        return (            &lt;div&gt;            \t&lt;div dangerouslySetInnerHTML=&#123;&#123;__html:this.ModelDemo&#125;&#125;&gt;&lt;/div&gt;            &lt;/div&gt;        )    &#125;  &#125;\n\n属性(props)\n正常情况下，props是从外部传入到组件内部或者组件内部自己初始化的，但是props不能被组件自己更改，但是可以通过父组件主动重新渲染的方式来传入新的props\n\n如何向子组件传输props\n只需要在父组件引用创建子组件的时候，在标签中以属性的方式设置好要传递给该子组件的props即可实现。\n\n以下这段代码就是在Father组件内引用了Chile这个组件\n分别两次在该组件的dom上创建了Chile组件\n给第一个Chile传递了num&#x3D;123、name&#x3D;’xsdw’ 、idths&#x3D;‘adda这些个props\n给第二个Chile传递了xx&#x3D;33的props\n\nimport React, &#123; Component &#125; from &#x27;react&#x27;import Chile from &#x27;../PropsCom/Chile.js&#x27;export default class Father extends Component &#123;    render() &#123;        return (            &lt;div&gt;                &lt;Chile num=&#123;123&#125; name=&#123;&#x27;xsdw&#x27;&#125; idths=&#123;&#x27;adda&#x27;&#125; /&gt;                &lt;Chile xx=&#123;33&#125; /&gt;            &lt;/div&gt;        )    &#125;&#125;\n\n如何在子组件内接收调用父组件传递过来的props\n在React的每个组件中都有一个props的对象属性，该属性就是专门用来接收父组件向该组件传递过来的props内容的，从父组件传递过来的所有prop都会放在该props对象内。\n所以我们只需要this.props.[objectname]即可调用父组件传递过来的props\nimport React, &#123; Component &#125; from &#x27;react&#x27;export default class Chile extends Component &#123;//将传递过来的props放在state里面 state=&#123;     propx:this.props &#125; render() &#123;     return (         &lt;div&gt;         \t&#123;/*直接调用props对象来使用*/&#125;             &#123;this.props.num&#125;         &lt;/div&gt;     ) &#125;&#125;\n\n子组件中限制传进来的props属性的数据类型\nReact项目下中提供了一个prop-types模块来支持我们在组件中去限制父组件传过来的props属性的数据类型\n\n也就是说相当于通过该模块即可预先给该组件内需要从父组件传递过来的属性进行类型设置。\n同时，当父组件传递对应属性的值过来的时候会自动检查是否符合预先设置的数据类型，如果不一致则会报错。\n\n\n实现步骤：\n\n先导入import PropTypes from ‘prop-types’ （注意：无需安装，直接引入即可）\n\n在子组件中定义静态属性propTypes\n//定义静态属性static propTypes = &#123;\t//props属性名：PropTypes.类型\ttitle: PropTypes.类型&#125;\n\n实际应用\nimport React, &#123; Component &#125; from &#x27;react&#x27;import PropTypes from &#x27;prop-types&#x27;export default class Sub extends Component &#123;    static propTypes = &#123;        //设置为number类型        num: PropTypes.number    &#125;    render() &#123;        return (            &lt;div&gt;                &lt;h2&gt;&#123;this.props.num&#125;&lt;/h2&gt;            &lt;/div&gt;        )    &#125;&#125;\n\n设置子组件的某个props属性必须在使用的时候给其传值\n只需要在子组件内设置propTypes的时候加上isRequired即可\n\nimport React, &#123; Component &#125; from &#x27;react&#x27;import PropTypes from &#x27;prop-types&#x27;export default class Sub extends Component &#123;    static propTypes = &#123;        // num: PropTypes.number.isRequired   //设置为isRequired表示必须传值        num: PropTypes.number.isRequired    &#125;    render() &#123;        return (            &lt;div&gt;                &lt;h2&gt;&#123;this.props.num&#125;&lt;/h2&gt;            &lt;/div&gt;        )    &#125;&#125;\n\n设置默认值如果直接在propTypes内对属性设置初始默认值，则以该值为默认值的同时限制该值的类型为默认值的类型\n传值的时候简写\n由于我们之前通过父组件将多个属性传给子组件的时候需要一个一个调用去传值\n为了简写，React支持ES6的简写的方式去传值\n也就是说，当给子组件传的值中属性名与父组件的相同的情况下，我们可以将这些个属性在父组件中使用Object的形式封装起来然后直接在标签内设置{…obj},react就会将该Object中属性名与子组件相同的属性对应进行解构赋值。\n\n\n父组件\n\nimport React, &#123; Component &#125; from &#x27;react&#x27;import Chile from &#x27;../PropsCom/Chile.js&#x27;export default class Father extends Component &#123;    render() &#123;       var Obj=&#123;            a:&#x27;FatherA&#x27;,            b:&#x27;FatherB&#x27;        &#125;        return (            &lt;div&gt;                &lt;Chile num=&#123;123&#125; name=&#x27;chile&#x27; &#123;...Obj&#125; /&gt;            &lt;/div&gt;        )    &#125;&#125;\n\n\n子组件\n\nimport React, &#123; Component &#125; from &#x27;react&#x27;import CheckPropTypes from &#x27;prop-types&#x27;export default class Chile extends Component &#123;    state=&#123;        propx:this.props    &#125;    render() &#123;        return (            &lt;div&gt;                num=&#123;this.props.num&#125;                &lt;h1&gt;name=&#123;this.props.name&#125;&lt;/h1&gt;                obj.a=&#123;this.props.a&#125;                obj.b=&#123;this.props.b&#125;            &lt;/div&gt;        )    &#125;    &#125; \n\n函数式组件内的Props\n在函数式组件内实现通过props将父组件的数据传递到子组件，只需要在函数式的函数的形参列表上定义一个参数用于接收父组件传递过来的prop即可，React会把所有 传递过来的prop都封装到指定的形式参数中\n\nimport React from &#x27;react&#x27;//通过props去接收父组件传递过来的props，会将所有传进来的prop都放在props里面export default function FunChile(props) &#123;  let ThisProps=props  console.log(ThisProps);  return (    &lt;div&gt;        this is FunChile         &lt;br/&gt;        &#123;ThisProps.bg&#125;    &lt;/div&gt;  )&#125;\n\nProps VS state相同点两者都是纯JS对象，都会触发render更新，都具有确定性\n不同点\n属性可以从父组件获取，状态不能\n属性可以有父组件修改，状态不能\n属性和状态都可以在内部设置默认值，但是方式不同\n属性不在组件内部进行修改，状态得在组件内部进行修改\n属性可以设置子组件初始值，状态不能\n属性可以修改子组件的值，状态不能\n\nstate\nstate的主要作用是用于组件保存、控制、修改组件的可变状态，state在组件内部初始化\nstate可以被组件自身修改，而外部不能访问也不能修改\nstate可以被认为是一个局部的，只能被组件自身控制的数据源\nstate中状态可以通过this.setState方法进行更新，setState会导致组件的重新渲染\n\nProps\nprops的主要作用是让使用组件的父组件可以传入参数来配置该组件。\nprops是外部传进来的配置参数\n组件内部无法控制也无法修改\n除非父组件重新传入新的props，不然组件的props是不变的\n\n表单的受控与不受控React中的表单组件，分为2类\n\n不受控组件（和状态无关）\n在input标签组件中，使用ref属性，来代表组件标识 \n组件渲染后，会自动把有ref属性的dom对象，挂到this.refs上 this.refs &#x3D; { ref名1 ： dom对象 ref名2 ： dom对象 } \n在需要的场景（一般指回调），使用this.refs来获取需要的对象，然后再做dom操作\n\n\n受控组件（和状态紧密相连）  \n初始化状态  \n在input标签的value属性上，绑定状态（输入框的默认值和状态有关）\n在input标签上维护onChange属性，触发时即时修改状态\n自动：当状态修改，立即触发声明周期的render方法，显示最先的状态值\n\n\n\n\n使用： 如果对值的控制度不高，直接不受控组件 如果要严格把控值的操作，受控可以做表单验证等严格的逻辑(推荐)\n\n组件之间的通信父子组件通信方式\n父传子—-采用传递数据\n子传父—-采用传递方法\nref标记（父组件拿到子组件的引用，从而调用子组件的方法）\n\n子传父通信的描述\n我们通过前面的属性props知道了可以通过props来实现父组件对子组件的传值操作。\n但是在实际应用当中我们不止需要通过父组件向子组件进行传值，我们还存在子组件向父组件传值的场景。\n\n如何实现子组件向父组件传值：\n与父传子不同的是，父传子是通过props属性对节点的绑定实现的传值，也就是说，直接通过对props传递数据实现\n子传父与父传子不同的是，通过向子组件的props上挂载一个方法，然后再子组件去调用props中的这个方法，以形式参数的方式将子组件的数据传入该方法从而实现将子组件的数据传递到父组件\n\n子组件向父组件传值的具体实现\n在父组件定义一个用于接收从子组件传递参数的方法\n\n该方法一般情况下定义有接收子组件数据的变量\n\n\n然后再对应的父组件上将刚刚定义的数据传递方法挂载到子组件的props属性上\n&lt;父组件名  挂载在子组件props的方法名=&#123;this.父组件定义的用于接收子组件数据的方法.bind(this)&#125;  /&gt;\n\n通过以上两步，我们就已经将传递数据的方法挂载在子组件的props上了\n\n接下来，我们就需要在子组件相应的地方去调用父组件挂载在子组件的props属性上的传递数据方法，并将要传递的参数通过形式参数传递到方法内部并执行该方法，从而实现数据的传递\n\n\n/**\t\t\t\t父组件*/import React, &#123; Component &#125; from &#x27;react&#x27;import ChildToFat from &#x27;./childToFat&#x27;export default class componentName extends Component &#123;    state=&#123;        name:&#x27;&#x27;    &#125;    MyEvent = (arg)=&gt;&#123;        this.setState(&#123;            name:arg        &#125;)    &#125;    render() &#123;        return (            &lt;div&gt;                &lt;ChildToFat propsEvent=&#123;this.MyEvent.bind(this)&#125;/&gt;                &#123;this.state.name&#125;            &lt;/div&gt;        )    &#125;&#125;\n\n/**\t\t子组件*/import React, &#123; Component &#125; from &#x27;react&#x27;export default class ChildToFat extends Component &#123;    state=&#123;        log:&#x27;child&#x27;    &#125;    render() &#123;        return (            &lt;div&gt;          &#123;/*           \t\t点击这个按钮调用父组件传过来的MyEvent函数，          \t\t也就是说，想要实现子传父通信，          \t\t可以通过在子组件内部调用父组件传过来的回调函数来实现           \t*/&#125;                &lt;button onClick=&#123;()=&gt;&#123;this.props.MyEvent(&#x27;child&#x27;)&#125;&#125; &gt;子传父&lt;/button&gt;            &lt;/div&gt;        )    &#125;&#125;\n\n\n\n非父子组件通信方式状态提升（中间人模式）\n也就是说，将多个组件需要共享的状态提升到他们最近的父组件上，然后互相通过父组件向对方传递props，从而实现非父子间的通信，这里的父组件也就起到了中间人的作用\n\n发布订阅模式实现数据的多级传递（context状态数传参）\n通过使用context机制进行数据的多级传递 ，在context机制当中需要在子组件内设置静态属性contextTypes，同时在其内部通过prop-types模块去设置需要多级传递的数据的数据类型。然后就是要在上层组件的内部设置有静态属性childContextTypes，并在其内部设置与子组件contextTypes内部相同的数据以及数据类型，且在上层组件内部需要设置getChildContext（）方法去获取子组件的上下文，同时去设置上下文的值。最后就是要在子组件内通过this.context.[属性]获取上层组件传递过来的数据\n\nimport React, &#123; Component &#125; from &#x27;react&#x27;import Fat from &#x27;./Fat&#x27;import PropTypes from &#x27;prop-types&#x27;/** *  * 爷爷组件 *  */export default class FatSDie extends Component &#123;    //设置childContextTypes    static childContextTypes=&#123;        name:PropTypes.string    &#125;    state=&#123;        name:&#x27;112&#x27;    &#125;    //获取设置子组件上下文    getChildContext()&#123;        return&#123;            name:this.state.name        &#125;    &#125;        render() &#123;        return (            &lt;div&gt;                &lt;Fat/&gt;            &lt;/div&gt;        )    &#125;&#125;\n\nimport React, &#123; Component &#125; from &#x27;react&#x27;import Child from &#x27;./Child&#x27;/** *  * 父亲组件 *  */export default class fat extends Component &#123;    render() &#123;        return (            &lt;div&gt;                &lt;Child&gt;&lt;/Child&gt;            &lt;/div&gt;        )    &#125;&#125;\n\nimport React, &#123; Component &#125; from &#x27;react&#x27;import PropTypes from &#x27;prop-types&#x27;/** *  *      儿子组件 *  */export default class Child extends Component &#123;    static contextTypes=&#123;        name:PropTypes.string    &#125;    render() &#123;        return (            &lt;div&gt;                &#123;/* 获取上层组件传递的参数 */&#125;                childName:&#123;this.context.name&#125;            &lt;/div&gt;        )    &#125;&#125;\n\nReact中的插槽在React中对于插槽的实现，就是当我们在一个组件标签内去插入dom的时候，React会自动将被插入的这段dom挂载在组件的props的children上，然后只需要在子组件内部调用this.props.children，React就会自动将被插入的dom渲染在组件上，而且我们需要知道的是，react会将被插入的dom段作为一个Array类型的数据挂载在组件的props的children上。\n\n父组件\n\nimport React, &#123; Component &#125; from &#x27;react&#x27;import Sole from &#x27;./sole.js&#x27;export default class soleFat extends Component &#123;    render() &#123;        return (            &lt;div&gt;                &lt;Sole name=&#123;&#x27;name&#x27;&#125;&gt;                    &lt;div&gt;                        &lt;h1&gt;H1&lt;/h1&gt;                    &lt;/div&gt;                    &lt;br&gt;&lt;/br&gt;                    &lt;h2&gt;H2&lt;/h2&gt;                &lt;/Sole&gt;                           &lt;/div&gt;        )    &#125;&#125;\n\n\n子组件\n\nimport React, &#123; Component &#125; from &#x27;react&#x27;export default class sole extends Component &#123;    render() &#123;        return (            &lt;div&gt;                &#123;this.props.children&#125;                       &lt;/div&gt;        )    &#125;    log=()=&gt;&#123;        console.log(this.props.children);    &#125;&#125;\n\nReact的生命周期React Hooks\n由于纯函数组件没有state、没有生命周期、没有this，这就使得纯函数组件只能作为UI展示的功能，但是当我们需要在一个函数式组件上涉及到state的管理和切换或者对生命周期的应用的时候，就不得不去使用redux或者修改为类组件，这样就显得特别的繁琐。于是React为我们提供了Hooks ，Hooks可以让你在不编写 class 的情况下使用 state 以及其他的 React 特性。\n\nUseState\n在函数式组件上使用state\n\n\n通过从react中解构引入useState来为一个函数式组件创建一个State\n\n/*\n        其中的num就是我们创建的一个state，useState()的参数就是创建的state的初始值\n        同时，我们可以注意到[]中的setName -- 这也是需要从useState中解构出来的一个函数，用于管理state--naem\n*/\n\nconst [name,setName] = useState (0)  //创建一个State,类似于我们在类组件内声明的 state=&#123; name : 0&#125;\n- Hook是的定义是不能放在条件判断中的  ```js  //这种写法是错误的  if()&#123;  \t\tconst [name,setName] = useState (0)    &#125;\n\n\nHook的所有api都只能在函数内的最外层进行创建声明\n\n\nimport React,&#123;useState&#125; from &#x27;react&#x27; export default function UseState() &#123;    const [name,setName]=useState(&quot;name&quot;)  return (    &lt;div&gt;        &#123;name&#125;        &lt;button onClick=&#123;()=&gt;&#123;            setName(&#x27;upName&#x27;)        &#125;&#125;&gt;修改name&lt;/button&gt;    &lt;/div&gt;  )&#125;\n\nUseEffect\n\n由于函数式组件是没有生命周期机制的，但是我们在实际应用的过程当中很难避免在函数式组件内部不使用到生命周期去做一些操作，所以React Hooks就提供了UseEffect让我们可以在函数式组件内部去实现生命周期的一些操作\nUseEffect在一个组件中可以多次定义\n\n\n检测数据变化\n在class组件中，我们检测组件的加载以及数据的变化是通过componentDidMount与componentDidUpdate这两个生命周期的钩子函数来实现的\n对于函数式组件来说，由于本身不带有生命周期，于是Hooks就通过UseEffect来实现对数据变化的检测\n\n\n在Hooks中一个UseEffect就可以替代componentDidMount与componentDidUpdate这两个生命周期函数。\n\nUseEffect函数什么时候执行呢？\n当该组件被加载的时候，UseEffect函数就会执行一次\n当UseEffect监测的state被更新的时候就会执行一次\n\n指定UseEffect函数监测的stateUserEffect函数的第一个参数就是我们可以设置的一个回调函数\n给UserEffect函数设置第二个参数，第二个参数以数组类型存在，将我们需要监测的state放在该数组中即可。\nimport React,&#123;useEffect, useState&#125; from &#x27;react&#x27;export default function UesEffect() &#123;    const [name,setName] = useState(&#x27;UseEffect&#x27;);    const [num,setNum] = useState(0)    //设置只监测name    useEffect(()=&gt;&#123;        console.log(&#x27;监测到数据更新&#x27;);    &#125;,[name])    return (        &lt;div&gt;            &lt;h1&gt;&#123;name&#125;&lt;/h1&gt;            &lt;h1&gt;&#123;num&#125;&lt;/h1&gt;            &lt;button onClick=&#123;()=&gt;&#123;                    setName(name+&#x27;ree&#x27;)                    setNum(num+2)            &#125;&#125;&gt;                clickUesEffect            &lt;/button&gt;        &lt;/div&gt;  )&#125;\n\n\n注意\nUesEffect是异步的，不会阻断视图更新\n\n关于UseEffect应用在组件销毁\n通过UseEffect实现函数式组件在被销毁的时候执行相应的操作，\n直接在UesEffect函数中添加一个return代码块，那么在该组件被销毁的时候就会自动指定return下的代码块\n需要注意的时候：\n\n当我们的UseEffect函数中声明return来执行组件销毁操作的同时该函数没有对任何state进行监测的时候，该UseEffect函数只会在组件被创建以及销毁的时候执行\n当我们的UseEffect函数中声明return来执行组件销毁操作的同时该函数存在对state进行监测,那么每次对应的state更新的时候,不仅执行return以为的函数体，还会同时执行return内的函数体\n\n\n\n不对state进行监测\n\nimport React,&#123;useEffect, useState&#125; from &#x27;react&#x27;export default function UesEffect() &#123;    const [name,setName] = useState(&#x27;UseEffect&#x27;);    //设置只监测name    useEffect(()=&gt;&#123;        console.log(&#x27;监测到数据更新&#x27;);        //当组件被销毁的时候会自动执行return下的函数        return()=&gt;&#123;            console.log(&#x27;销毁&#x27;);        &#125;    &#125;,[])    return (        &lt;div&gt;            &lt;h1&gt;&#123;name&#125;&lt;/h1&gt;            &lt;button onClick=&#123;()=&gt;&#123;                    setName(name+&#x27;ree&#x27;)            &#125;&#125;&gt;                 clickUesEffect            &lt;/button&gt;        &lt;/div&gt;  )&#125;\n\n\n对state进行监测\n\nimport React,&#123;useEffect, useState&#125; from &#x27;react&#x27;export default function UesEffect() &#123;    const [name,setName] = useState(&#x27;UseEffect&#x27;);    //设置只监测name    useEffect(()=&gt;&#123;        console.log(&#x27;监测到数据更新&#x27;);        //当组件被销毁的时候会自动执行return下的函数        return()=&gt;&#123;            console.log(&#x27;销毁&#x27;);        &#125;    &#125;,[name])    return (        &lt;div&gt;            &lt;h1&gt;&#123;name&#125;&lt;/h1&gt;            &lt;button onClick=&#123;()=&gt;&#123;                    setName(name+&#x27;ree&#x27;)            &#125;&#125;&gt;                 clickUesEffect            &lt;/button&gt;        &lt;/div&gt;  )&#125;\n\nuseCallback（记忆函数）\n由于在函数式组件中，当组件内部存在数据更新的时候，就会对组件进行重新渲染。同时，被定义在函数内部的一些临时的变量就会被重新加载，这样就会导致这些个临时变量会被重新声明创建赋值。为了解决这个问题，hooks就为我们提供了useCallback函数，通过该函数实现对数据的缓存。\n\nuseRef(保存引用值)\n与class组件的react.createRef()创建ref对象一样的作用，创建一个ref对象用于挂载在对应的dom节点上，然后通过调用对应的ref对象来获取对应dom节点的信息。\n\nimport React from &#x27;react&#x27;import &#123;useRef&#125; from &#x27;react&#x27;export default function useRefCom() &#123;    const InputTextRef = useRef()    return (    &lt;div&gt;        &lt;input type=&#x27;text&#x27; ref=&#123;InputTextRef&#125; &gt;&lt;/input&gt;        &lt;button onClick=&#123;()=&gt;&#123;            console.log(InputTextRef.current.value);           &#125;&#125; &gt;inputValue&lt;/button&gt;    &lt;/div&gt;  )&#125;\n\nuseContext使用useContext实现组件间传值的步骤：\n\n在上层组件内引入createContext\nimport &#123;createContext&#125; from &#x27;react&#x27;\n\n在上层组件内通过createContext创建Context对象,并暴露它以便在子组件内引用\nexport const myContext = createContext();\n\n在上层组件引用的子组件外使用Context对象的Provider属性将子组件包住，并以value传值\n&lt;myContext.Provide valuie=&#123;...&#125;&gt;\t\t&lt;Child/&gt;&lt;/myContext.Provide&gt;\n\n在子组件内部引入上层组件的Context对象\n\n在子组件内部引入useContext\n\n在子组件内部使用useContext读取上下文对象，这里我们需要知道的是，useContext接收一个 context 对象（React.createContext 的返回值）并返回该 context 的当前值。当前的 context 值由上层组件中距离当前组件最近的 &lt;MyContext.Provider&gt; 的 value prop 决定。\nimport React, &#123; useContext &#125; from &#x27;react&#x27;import &#123;FatContext&#125; from &#x27;./fat.js&#x27;export default function Child() &#123;    const num = useContext(FatContext)  return (    &lt;div&gt;                &#123;num&#125;    &lt;/div&gt;  )&#125;\n\n","categories":["前端"],"tags":["前端","react"]},{"title":"关于cookie的一些特性","url":"/2022/12/15/cookie/","content":"什么是cookie\ncookie是由服务器端生成的通过请求发送给客户端的\n浏览器会将服务器端发送过来的cookie保存为某一个目录下的文件\n浏览器接收到cookie就会把这个cooki对象存入浏览器缓存中\ncookie实际上是一些信息，这些信息以文件的形式存储在客户端计算机上\n\ncookie的生命周期\n如果不设置过去时间，则表示该cookie生命周期为浏览器会话期间，只要关闭了浏览器窗口，cookie就消失了\n\n在手动情况下，可以设置浏览器接收的cookie存放在电脑硬盘中，那么cookie的有效时间可以为我们来设置。当我们设置好了这个时间，就算浏览器关闭了，cookie对象也不会被销毁。\n\n设置cookie的有效时间\ncookie.setMaxAge(60)   //60秒\ncookie的什么周期浏览器的会话时间的cookie被称为会话cookie\n\n会话cookie一般不保存在硬盘上而是保存在内存中\n\n如果设置了过期时间，那么浏览器就会把cookie保存到硬盘上，关闭后再次打开浏览器，这些cookie依然有效，除非超过了有效时间\n\n存储在硬盘上的cookie可以在不同浏览器进程之间共享。\n\n\ncookie的分类\n如果创建了一个cookie，并将他发送到浏览器，默认情况下它是一个会话级别的cookie，存储在浏览器的内存中，用户退出浏览器之后被删除\n如果希望浏览器将cookie存储在磁盘上，则需要使用maxAge，并给出一个以秒为单位的时间\n\n会话Cookie不设置过期时间，则表示这个cookie生命周期为浏览器会话期间，只要关闭浏览器窗口，cookie就消失了。\n持久Cookie设置了过期时间，浏览器就会把coolie保存到硬盘上，且不会随浏览器关闭而消失，除非用户手工清理或到了过期时间，关闭后再次打开浏览器。\ncookie的存储\ncookie是类似存储在本机的\ncookie只能页面通过服务打开的情况下才可以使用。\ncookie存储的数据类型是字符串\ncookie存储是以域名区分的，不同域名的存储是无法共享的\n\ncookie的缺点\ncookie可能被禁用。当用户非常注重个人隐私保护时，他很可能禁用浏览器的cookie功能；\ncookie是与浏览器相关的。这意味着即使访问的是同一个页面，不同浏览器之间所保存的cookie也是不能互相访问的；\ncookie可能被删除。因为每个cookie都是硬盘上的一个文件，因此很有可能被用户删除；\ncookie安全性不够高。所有的cookie都是以纯文本的形式记录于文件中，因此如果要保存用户名密码等信息时，最好事先经过加密处理。\n\n","categories":["前端"],"tags":["前端","网络相关","cookie"]},{"title":"关于webpack暴力笔记","url":"/2022/12/14/webpack/","content":"什么是webpackwebpack是一种前端资源构建工具，一个静态模块打包器（module bundler）\n在webpack角度看，前端的所有资源文件都会作为模板处理，webpack将工具模块的依赖关系进行静态分析，打包生成对应的静态资源。\n简述webpack的工作流程\n首先我们需要为webpack的执行提供一个js文件作为打包入口文件\n而作为一个入口文件，这个文件内就需要将需要进行打包的文件进行引入，例如图片资源、css样式资源等等\n当我们执行相对于的命令开始进行打包的时候，webpack就会根据这个入口文件作为起点开始打包\n然后webpack就会去解析这个入口文件内声明的需要打包的资源，然后在webpack内部生成一个依赖关系树状结构图\n由于声明在入口文件内需要进行webpack打包的目标资源其内部也会存在需要进行打包的资源，所以webpack会以树形结构去将这些需要打包的依赖关系资源进行规划，然后生成一个关于该项目下的依赖关系树状结构图\n当这个依赖关系树形结构图生成之后，webpack就会去根据这个树形结构中记录的资源进行引入到项目，生成一个东西，我们称为chunk。\n在chunk生成成功之后，webpack就会去处理这个chunk，例如需要将less文件编译为css文件。这个处理的过程操作就称为”打包”。\n执行成功打包操作之后，webpack会将打包结果”bundle”进行输出，打包完成。\n\n\n综上所述，webpack就是根据项目下提供给webpack的入口文件去得到项目内资源的依赖关系，然后内部生成一个依赖关系树状结构图，然后这个依赖关系一步步的对资源进行打包的过程。\n\nwebpack的五个概念Entry（入口）用于指示webpack以哪个文件作为起点进行打包分析建内部依赖图\nOutput（输出）用于指示webpack打包后的资源bundles输出到哪里去，以及对bundles的命名\nLoader由于webpack自身只理解JavaScript，但是我们需要webpack去打包的资源不止是js文件，所以我们需要提供一个东西让webpack去处理那些非JavaScript的资源，这就是Loader\nPlugins插件，可以用于执行一些范围较广的任务。插件的范围包括，从打包到优化、压缩，一直到重新定义环境变量等等\nMode![截屏2022-03-09 上午8.03.00](&#x2F;Users&#x2F;carray&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;截屏2022-03-09 上午8.03.00.png)\n运行指令开发模式webpack 打包入口文件路径  -o 打包输出路径  --mode=development\n\n生产模式webpack 打包入口文件路径  -o 打包输出路径  --mode=production\n\nwebpack配置文件\n在项目同级目录下创建一个webpack-config.js,作为webpack的配置文件\n该配置文件一般都包含有webpack五个概念的配置项\n我们也是通过这个配置文件来定义相应的loader让webpack去对js文件以外的资源进行打包\n\n/** * webpack-config.js  *      所有构建工具都是基于nodejs平台运行的~模块化默认采用commonjs *///resolve来自于nodejs的一个模块，是用来拼接绝对路径的方法const &#123;resolve&#125; =require(&#x27;path&#x27;)module.exports=&#123;    entry:&#x27;./src/index.js&#x27;,              //入口起点路径    //定义输出配置    output:&#123;        filename:&#x27;build.js&#x27;,              //输出的文件名        //__dirname 是nodejs的一个变量，代表当前文件所在目录的绝对路径        path:resolve(__dirname,&#x27;build&#x27;)     //输出路径    &#125;,    //loader的配置，让webpack处理除了js以外的资源    module:&#123;        rules:[        ]    &#125;,    //plugins的配置    plugins:[    ],    mode:&#x27;development&#x27;    //mode：&#x27;production&#x27;&#125;\n\ncss-loader运行当我们没有采用derserver类似的配置的时候，为了实现webpack打包的时候，当我们修改文件就自动重新打包，我们可以在webpack命令后加一个–watch\nwebpack --watch\n\ndevserver实现devserver需要在对webpack.config.js配置文件进行配置\n//添加配置项devServer:&#123;\tstatic:&#x27;./pack&#x27;  //配置static指向打包后的bundle的输出文件夹路径作为devserver的根路径&#125;\n\n\n对于webpack-dev-server运行之后是没有真正去生成bundle文件的，而是把打包输出的bundle文件放到内存中运行\n\n\n添加了以上的devserver配置之后，我们通过命令行执行npx webpack-dev-server,可以看见在本地8080端口开启了一个服务，我们只需要在游览器访问该url就可以访问到打包后的bundle的根目录，如果我们在bundle的输出目录下存在app.html文件，我们只需要访问http://localhost:8080/app.html，即可访问该html文件\n![截屏2022-03-16 上午9.08.03](&#x2F;Users&#x2F;carray&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;截屏2022-03-16 上午9.08.03.png)\n\n资源模块资源模块(asset module)是一种模块类型，它允许使用资源文件（字体，图标等）而无需配置额外 loader。\n在 webpack 5 之前，通常使用：\n\nraw-loader 将文件导入为字符串\nurl-loader 将文件作为 data URI 内联到 bundle 中\nfile-loader 将文件发送到输出目录\n\n资源模块类型(asset module type)，通过添加 4 种新的模块类型，来替换所有这些 loader：\n\nasset/resource 发送一个单独的文件并导出 URL。之前通过使用 file-loader 实现。\nasset/inline 导出一个资源的 data URI。之前通过使用 url-loader 实现。\nasset/source 导出资源的源代码。之前通过使用 raw-loader 实现。\nasset 在导出一个 data URI 和发送一个单独的文件之间自动选择。之前通过使用 url-loader，并且配置资源体积限制实现。\n\n当在 webpack 5 中使用旧的 assets loader（如 file-loader&#x2F;url-loader&#x2F;raw-loader 等）和 asset 模块时，你可能想停止当前 asset 模块的处理，并再次启动处理，这可能会导致 asset 重复，你可以通过将 asset 模块的类型设置为 &#39;javascript/auto&#39; 来解决。\n设置资源模块打包输出路径\n只需要在output配置中添加配置项—&gt;assetModuleFilename\n\n![截屏2022-03-16 上午9.34.19_副本](&#x2F;Users&#x2F;carray&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;截屏2022-03-16 上午9.34.19_副本.png)\n抽离和压缩css抽离css\n\n之前我们在webpac.config.js中配置的处理css的loader在经过webpack执行打包之后都会把css打包到对应的js文件中去，然后通过htmlwebpackplugin插件自动将该js文件通过script标签引入到我们指定给htmlwebpackplugin的模板html文件中去，从而实现对css的打包。\n但是我们也可以的对打包的css之类的样式资源文件通过webpack打包之后抽离为一个单独的css文件，然后通过htmlwebpackplugin这个插件将该css文件通过link标签引入到html中。\n\n\n大多数情况下，我也可以对css进行压缩，一边在生产环境中节省加载时间，同时还可以将css文件抽离成一个单独的文件，为了实现这个功能，我们需要在webpack项目下安装 [mini-css-extract-plugin]这个插件\nnpm i mini-css-extract-plugin -d\n\n\n\n这个插件会将css提取到单独的文件中，为每个包含css的js文件创建一个css文件\n也就是说，通过webpack配置打包的css资源文件会被打包单独打包抽离为一个单独的css文件，然后webpack会自动通过htmlwebpackplugin将这个被单独抽离抽离的打包完成的css文件在html的head里面引入。\n\n\n首先就是要在项目下安装插件\nnpm i mini-css-extract-plugin -d\n然后然后就是要在webpack.config,js中引入和使用该插件\nconst &#123;resolve&#125; =require(&#x27;path&#x27;)const HtmlWebpackPlugin=require(&#x27;html-webpack-plugin&#x27;)/**\t引入插件*/const MiniCssExtractPlugin=require(&#x27;mini-css-extract-plugin&#x27;)module.exports=&#123;    entry:&#x27;./src/index.js&#x27;,              //入口起点路径    output:&#123;        filename:&#x27;pack.js&#x27;,              //输出的文件名        path:resolve(__dirname,&#x27;pack&#x27;),     //输出路径    &#125;,    module:&#123;        rules: [            &#123;              test: /\\.less$/,              //配置loader，调用MiniCssExtractPlugin对象的loader属性              use: [MiniCssExtractPlugin.loader, &#x27;css-loader&#x27;,&#x27;less-loader&#x27;]            &#125;          ]    &#125;,    plugins:[        new HtmlWebpackPlugin(&#123;          template:&#x27;./src/index.html&#x27;        &#125;),     \t //实例化该插件        new MiniCssExtractPlugin()    ],    mode:&#x27;development&#x27;&#125; \n以上就是对css抽离的操作，在less-loader和css-loader对less样式资源处理之后MiniCssExtractPlugin插件对象的loader就会对样式资源进行抽离然后生成一个单独的css文件。\n\n\n\n抽离css的时候怎么自定义文件在输出目录的路径只需要在实例化MiniCssExtractPlugin对象的时候进行配置即可\nplugins:[\t\tnew MiniCssExtractPlugin(&#123;\t\t\t\t//表示将文件存放在输出目录下的styles中\t\t\t\tfilename:&#x27;styles/[contenthash][ext]&#x27;\t\t&#125;)]\n\n压缩css\n安装插件css-minimizer-webpack-plugin\nnpm i css-minimizer-webpack-plugin  -d \n在webpack.config.js配置，首先引入该插件然后在optimization配置项中实例化，然后要吧mode的值修改为production\nconst &#123;resolve&#125; =require(&#x27;path&#x27;)const HtmlWebpackPlugin=require(&#x27;html-webpack-plugin&#x27;)//引入css-minimizer-webpack-pluginconst CssMinimizerWebpackPlugin = require(&#x27;css-minimizer-webpack-plugin&#x27;)/**\t引入插件*/const MiniCssExtractPlugin=require(&#x27;mini-css-extract-plugin&#x27;)module.exports=&#123;    entry:&#x27;./src/index.js&#x27;,              //入口起点路径    output:&#123;        filename:&#x27;pack.js&#x27;,              //输出的文件名        path:resolve(__dirname,&#x27;pack&#x27;),     //输出路径    &#125;,    module:&#123;        rules: [            &#123;              test: /\\.less$/,              //配置loader，调用MiniCssExtractPlugin对象的loader属性              use: [MiniCssExtractPlugin.loader, &#x27;css-loader&#x27;,&#x27;less-loader&#x27;]            &#125;          ]    &#125;,    plugins:[        new HtmlWebpackPlugin(&#123;          template:&#x27;./src/index.html&#x27;        &#125;),     \t //实例化该插件        new MiniCssExtractPlugin()    ],   \t////////////////配置项在这    mode:&#x27;production&#x27;，  \toptimization:&#123;  \t\tminimizer:[  \t\t\tnew CssMinimizerPlugin()  \t\t]\t&#125;&#125; \n\n代码分离使用webpack打包的时候进行代码分离，可以将webpack打包后输出的bundle分离成更小的bundle，从而可以实现对打包后资源的按需加载或者并行加载，同时也可以控制资源加载的优先级。\n代码分离的三种方式\n入口起点\n防止重复\n动态导入\n\n入口起点（通过entry实现代码分离）在webpack配置文件中配置entry配置项去手动的分离代码，但是由于在entry配置项配置了多个打包入口就会导致这些入口中的都引入了相同的文件以至于对文件打包的时候会对同一个同一个文件多次打包\n![截屏2022-03-16 下午4.49.34](&#x2F;Users&#x2F;carray&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;截屏2022-03-16 下午4.49.34.png)\n防止重复由于采用在入口起点处配置entry实现代码分离会导致文件被重复打包，为了解决这一问题，可以在入口配置处使用Entry dependencise或者splitChunksPlugin对入口起点中的文件进行去重之后再执行打包\n![截屏2022-03-16 下午5.21.56](&#x2F;Users&#x2F;carray&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;截屏2022-03-16 下午5.21.56.png)\n使用SplitChunksPlugin创建抽离出共享的js文件SplitChunksPlugin 插件可以将公共的依赖模块提取到已有的入口 chunk 中，或者提取到一个新生成的 chunk。\n动态导入通过模块的内联函数调用来分离代码\n","categories":["前端"],"tags":["前端","webpack"]},{"title":"websocket和Ajax的区别","url":"/2022/12/15/websocket%E5%92%8CAjax%E7%9A%84%E5%8C%BA%E5%88%AB/","content":"websocket和Ajax的区别在本质上不同\nAjax是异步的JavaScript和xml\najax是一种创建交互式我也应用的网页开发技术\nwebsocket是html5的一种新的协议，实现了浏览器和服务器全双工通信\nwebsocket本质上是先通过http&#x2F;https协议进行握手后创建的一个用于交换数据的tcp链接，服务端与客户端通过这个TCP连接实现即时通信\n\n生命周期不同\nwebsocket建立的是一个长连接，在一个会话中会一直保持连接\najax是短链接，ajax在数据发送和响应接收之后就会断开连接\n\n适用范围不同\nwebsocket一般用于前后端实时数据的交互\najax用于前后端非实时 数据交互\n\n发起人不同\najax技术需要客户端发起请求，同时请求回来的数据也要用户自己看\nwebsocket服务器和客户端可以互相推送消息\n\n","categories":["前端","网络相关"],"tags":["前端","websocket","ajax"]},{"title":"一些关于TCP","url":"/2022/12/15/%E4%B8%80%E4%BA%9B%E5%85%B3%E4%BA%8ETCP/","content":"TCP三次握手\n首先我们知道，tcp是面相连接的。当某一方向另一方发送数据之前都必须在双方宅男建立tcp连接。\ntcp连接是通过三次握手进行初始化的\n三次握手的目的就是为了同步对方的序列号和确认号。\n过程：\n第一次握手：建立连接。客户端发送连接请求报文段，将SYN位置为1，Sequence Number为x;然后，客户端进入SYN_SEND状态，等待服务器的确认;\n第二次握手：服务器收到SYN报文段。服务器收到客户端的SYN报文段，需要对这个SYN报文段进行确认，设置Acknowledgment Number为x+1(Sequence Number+1);同时，自己自己还要发送SYN请求信息，将SYN位置为1，Sequence Number为y;服务器端将上述所有信息放到一个报文段(即SYN+ACK报文段)中，一并发送给客户端，此时服务器进入SYN_RECV状态;\n第三次握手：客户端收到服务器的SYN+ACK报文段。然后将Acknowledgment Number设置为y+1，向服务器发送ACK报文段，这个报文段发送完毕以后，客户端和服务器端都进入ESTABLISHED状态，完成TCP三次握手。\n\n\n\nTCP四次挥手可以被优化当服务器没有数据要发送给客户端的时候，tcp的四次挥手会被优化为三次\nTCP三次握手的目的为了防止生效的连接请求报文被服务端接受\n为什么TCP握手不用两次如果只有两次握手，假设当客户端发送第一次连接请求由于网络拥塞的原因，迟迟未到服务端，客户端没接收到确认报文，认为服务端没有收到，于是重新发送请求报文并与服务端建立连接，等这次连接断开了，之前滞留的那个请求报文又到达了服务端，就会让服务端与客户端再次连接成功，这时服务端就会一直等待客户端发送请求，造成了资源的浪费。\n","categories":["前端","网络相关"],"tags":["前端","浏览器","网络"]},{"title":"VUE生命周期和keep-alive小总结","url":"/2022/12/15/%E5%85%B3%E4%BA%8Evue%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%92%8Ckeep-live/","content":"Vue2.x生命周期生命周期有哪些vue自带的生命周期\n\nbeforeCreate（创建前） 在数据观测和初始化事件还未开始\ncreated（创建后） 完成数据观测，属性和方法的运算，初始化事件，$el属性还没有显示出来\nbeforeMount（载入前） 在挂载开始之前被调用，相关的render函数首次被调用。实例已完成以下的配置：编译模板，把data里面的数据和模板生成html。注意此时还没有挂载html到页面上。\n个人理解：对页面或者组件内部的template（模板）进行编译，将其编译为html，同时要在该组件或者页面的整个声明周期中首次对data对象进行调用，然后将data对象的数据跟模板一起生成对应的html。\n\n\nmounted（载入后） 在el 被新创建的 vm.$el 替换，并挂载到实例上去之后调用。实例已完成以下的配置：用上面编译好的html内容替换el属性指向的DOM对象。完成模板中的html渲染到html页面中。此过程中进行ajax交互。\nbeforeUpdate（更新前） 在数据更新之前调用，发生在虚拟DOM重新渲染和打补丁之前。可以在该钩子中进一步地更改状态，不会触发附加的重渲染过程。\nupdated（更新后） 在由于数据更改导致的虚拟DOM重新渲染和打补丁之后调用。调用时，组件DOM已经更新，所以可以执行依赖于DOM的操作。然而在大多数情况下，应该避免在此期间更改状态，因为这可能会导致更新无限循环。该钩子在服务器端渲染期间不被调用。\nbeforeDestroy（销毁前） 在实例销毁之前调用。实例仍然完全可用。\ndestroyed（销毁后） 在实例销毁之后调用。调用后，所有的事件监听器会被移除，所有的子实例也会被销毁。该钩子在服务器端渲染期间不被调用。\n\n进入到页面或者组件的时候会执行哪些生命周期以及顺序\n当刚刚开始进入到页面或者组件的时候，在没有对页面或者组件进行其他操作的情况下，会执行beforeCreate、created、beforeMount、mounted。\n\nvue 中的$el，$data，$options，$refs 属性含义\nvm.$el\n\n\n获取Vue实例关联的DOM元素；\n\n\nvm.$data\n\n\n获取Vue实例的data选项（对象）\n\n\nvm.$options\n\n\n获取Vue实例的自定义属性（如vm.$options.methods,获取Vue实例的自定义属性methods）\n\n\nvm.$refs\n\n\n获取页面中所有含有ref属性的DOM元素（如vm.$refs.btn，获取页面中含有属性ref = &quot;btn&quot;的DOM元素，如果有多个元素，那么只返回最后一个）\n\n在哪个阶段有$el,在哪个阶段会有$data\n首先$el代表着Vue实例所关联的Dom元素，$data代表着的是Vue实例所挂载的data对象\n然后我们知道在vue的生命周期中，在created阶段会对数据进行观测，所以在created阶段就会有$data的存在\n对于$el，由于在mounted被调用之前会将新创建的$el对象对原来的el挂载进行替换，所以真正意义上有$el的阶段是在mounted阶段\n\n如果加入了keep-alive会多出两个生命周期当我们的组件内部使用到的时候会多出两个生命周期activated、deactivated\n如果加入了keep-alive，第一次进入组件会执行哪些生命周期\nbeforeCreate\ncreated\nbeforeMount\nmounted\nactivated\n\n如果加入了keep-alive，第二次或者第n次进入该组件会执行哪些生命周期\n\n只会执行一个生命周期：activated\n\n\n谈谈对keep-alive的了解\n首先keep-alive是vue自带的一个组件\n功能：是用来缓存组件的，提升性能\n使用场景：\n例如我们在一个列表点击进入详情页的场景下，会出现每次进入该小企业就需要请求该详情也对应的数据，但是为了性能考虑，减少多次点击同一个详情页多次请求同一个数据，我们就可以通过利用keep-alive来实现对组件的缓存，由于keep-alive在第一次进入的时候会执行beforeCreate、created、brforeMount、mounted、activated这几个生命周期，那么当第一次进入的时候在created阶段就对对应的列表项详情进行获取请求并标记，在后面重新进入该组件的时候由于该组件的生命周期不会再执行activated之前的操作了，所以就可以在activated阶段对标记进行比较如果是原来的列表项则不需要重新请求数据，如果与原来的列表项不同了则重新请求数据并更新标记，以此来提高性能。\n\n\n\n","categories":["前端","Vue"],"tags":["前端","Vue"]},{"title":"关于前端的一些可视化","url":"/2022/12/15/%E5%85%B3%E4%BA%8E%E5%89%8D%E7%AB%AF%E5%8F%AF%E8%A7%86%E5%8C%96/","content":"数据可视化（Data Visualization）指将结构或非结构数据转换成适当的可视化图表，然后将隐藏在数据中的信息直接展现于人们面前。\n数据可视化工具绘图容器(画布)\nCanvas\nsvg\n\n绘图工具（插件）\necharts\nhighcharts\ncharts\nd3\nucharts\n\n数据可视化化工具的区别Canvas和SVG的区别Canvas\n依赖分辨率,都是标量图形\n不支持事件处理器(不能绑定事件)\n弱的文本渲染能力，适合游戏开发（微信小游戏）\n能够以 .png 或 .jpg 格式保存结果图像\n\nSVG：\n不依赖分辨率，矢量图形\n支持事件处理器\n最适合带有大型渲染区域的应用程序（比如谷歌地图）\n不适合游戏应用\n\nEcharts.js、D3.js、Highcharts.js的区别Echarts.js百度商业前端数据可视化团队研发的图表库,免费开源，国内用户偏多。可以使用canvas和svg绘制图形\nHighcharts.jshighcharts是国外的一家公司开发的图表库，主要采用svg画图。\nD3.jsD3通过svg来绘制图形，偏底层，太底层，学习成本大。\nCanvasCanvas本身是没有绘图能力的，Canvas本身是一个用于绘制图形的html标签，它在html中创建一个画布，作为一个绘图的容器然后通过JavaScript进行绘制。\n关于Canvas\n画布大小\n\ncanvas标签默认，width为300px;height为150px\n\ncanvas的单位为px\n\n不要使用style样式对canvas设置其大小，否则否则会导致内部图形变形，应该使用其本身的height和width属性来设置其大小\n&lt;canvas class=&quot;sector&quot; height=&quot;500px&quot; width=&quot;500px&quot; &gt;&lt;/canvas&gt;\n\n\n画布坐标\n\n画布的原点，理解为坐标系原点，默认为[0,0]\n\n\n\nCanvas上下文对象因为canvas本身不具备绘图能力，所以需要其内部的2d画笔对象来完成图形绘制，也就是canvas上下文对象，后面我们可以称其为画笔；\nlet canvas = document.getElementById(&#x27;canvas&#x27;);let ctx = canvas.getContext(&#x27;2d&#x27;);\n\n\ncanvas画图\n​    画笔：canvas.getContext(‘2d’);\n​    绘制线段：moveTo()  lineTo()  strokeStyle  stroke()    fillStyle  fill()  lineWidth…\n​    绘制矩形：rect()  fillRect()   strokeRect()  clearRect()\n​    绘制圆形：arc(x,y,r,startAng,endAng,bool) Math.PI（180） &#x3D;&#x3D; π  &#x3D;&#x3D; 3.14\n​    绘制文字：font   fillText()  strokeText()  textAlign  ….\n​    绘制图片  drawImage()  onload\n\ncanvas渐变\n​    线性渐变：linearGradient(x1,y1,x2,y2)\n​    径向渐变：radialGradient(cx1,cy1,r1,cx2,cy2,r2)\n\ncanvas变形​    rotate(弧度)  translate()  scale()  transform()\ncanvas状态保存和恢复\nsave()  \nrestore()\n\n持续更新……","categories":["前端","数据可视化"],"tags":["前端","Canvas","SVG","echarts"]},{"title":"在linux上部署属于自己的gitlab站点","url":"/2022/12/15/%E5%9C%A8linux%E4%B8%8A%E9%83%A8%E7%BD%B2%E5%B1%9E%E4%BA%8E%E8%87%AA%E5%B7%B1%E7%9A%84gitlab%E7%AB%99%E7%82%B9/","content":"1. 安装和配置必须的依赖项sudo apt-get update sudo apt-get install -y curl openssh-server ca-certificates tzdata perl  \n\n（可选）下一步，安装 Postfix 以发送电子邮件通知。如果您想使用其他解决方案发送电子邮件，请跳过此步骤并在安装极狐GitLab 后配置外部 SMTP 服务器。\nsudo apt-get install -y postfix  \n\n在安装 Postfix 的过程中可能会出现一个配置界面，在该界面中选择“Internet Site”并按下回车。把“mail name”设置为您服务器的外部 DNS 域名并按下回车。如果还有其它配置界面出现，继续按下回车以接受默认配置。\n2. 下载&#x2F;安装极狐GitLab配置极狐GitLab 软件源镜像。\ncurl -fsSL https://packages.gitlab.cn/repository/raw/scripts/setup.sh | /bin/bash  \n\n接下来，安装极狐GitLab。确保您已正确设置您的 DNS，并更改 https://gitlab.example.com 为您要访问极狐GitLab 实例的 URL。安装包将在该 URL 上自动配置和启动极狐GitLab。\n对于 https 站点，极狐GitLab 将使用 Let’s Encrypt 自动请求 SSL 证书，这需要有效的主机名和入站 HTTP 访问。您也可以使用自己的证书或仅使用 http://（不带s）。\n如果您想为初始管理员用户(root)指定自定义密码，请查看文档。如果未指定密码，将自动生成随机密码。\n执行如下命令开始安装：\nsudo apt-get install gitlab-jh  \n\n修改服务器地址，vim &#x2F;etc&#x2F;gitlab&#x2F;gitlab.rb\n external_url ‘http://192.168.0.110:60000‘\n同时也可以配置域名，gitlab设置external_url 默认不添加端口是占用80端口的，如果80端口被占用，一定要修改启动端口哦。\n（8）保存后，使用gitlab-ctl reconfigure重加载配置，时间可能稍久。启动好后，访问我们配置的端口，就可以看到下面初始化管理员（root）密码的页面了。\nlinux系统搭建gitlab详细：https://blog.csdn.net/m0_46109609/article/details/110866302\ndocker上搭建jenkins：https://blog.csdn.net/BThinker/article/details/124178670\n","categories":["gitlab"],"tags":["gitlab","linux"]},{"title":"谈谈对keep-alive的了解","url":"/2022/12/15/%E8%B0%88%E8%B0%88%E5%AF%B9keep-alive%E7%9A%84%E7%90%86%E8%A7%A3/","content":"谈谈对keep-alive的了解\n首先keep-alive是vue自带的一个组件\n功能：是用来缓存组件的，提升性能\n使用场景：\n例如我们在一个列表点击进入详情页的场景下，会出现每次进入该小企业就需要请求该详情也对应的数据，但是为了性能考虑，减少多次点击同一个详情页多次请求同一个数据，我们就可以通过利用keep-alive来实现对组件的缓存，由于keep-alive在第一次进入的时候会执行beforeCreate、created、brforeMount、mounted、activated这几个生命周期，那么当第一次进入的时候在created阶段就对对应的列表项详情进行获取请求并标记，在后面重新进入该组件的时候由于该组件的生命周期不会再执行activated之前的操作了，所以就可以在activated阶段对标记进行比较如果是原来的列表项则不需要重新请求数据，如果与原来的列表项不同了则重新请求数据并更新标记，以此来提高性能。\n\n\n\n","categories":["前端","Vue"],"tags":["前端","Vue"]},{"title":"Ubuntu设置Swap分区","url":"/2022/12/16/%E8%AE%BE%E7%BD%AEswep%E5%88%86%E5%8C%BA/","content":"查看系统是否配置Swapsudo swapon --show\n\n如果没有任何输出，表明系统没有配置swap\n查看系统存储空间df -h\n\n确保有足够的空间创建Swap分区\n创建分区文件sudo fallocate -l 1G /swapfile\n\n以上命令会在根目录创建大小为1G的文件，大小可根据需要进行调整，一般取和内存一般大小\n验证是否创建成功ls -lh /swapfile# output -rw-r--r-- 1 root root 1.0G Sep 14 13:02 /swapfile\n\n启用分区修改分区文件的权限，只允许root用户进行读取\nsudo chmod 600 /swapfilels -lh /swapfile# output -rw------- 1 root root 1.0G Sep 14 13:02 /swapfile\n\n将其标记为swap分区sudo mkswap /swapfile\n\n启用分区，允许系统开始使用sudo swapon /swapfile\n\n再次检查系统分区sudo swapon --show\n\n如果输出类似NAME      TYPE  SIZE USED PRIO/swapfile file 1024M   0B   -2\n\n表示分区已经创建成功\n将分区持久化目前已经在当前会话的启用的swap分区，但是如果系统重新启动，分区就会消失，我们可以通过修改/etc/fstab的配置来使分区持久化\necho &#x27;/swapfile none swap sw 0 0&#x27; | sudo tee -a /etc/fstab\n\n调整swap分区配置swappiness参数配置系统使用swap分区的频率，数字越小，系统对swap的依赖越小，如果设置为接近0的数字，那么内核只有在绝对必要情况下才会将数据交换到磁盘。应为和硬盘交换数据比RAM慢的多，所以这个数字越小，通常会让系统加快\nswappiness配置cat /proc/sys/vm/swappiness# output 60\n\n临时修改swappinesssudo sysctl vm.swappiness=10\n\n永久修改(推荐)&#x2F;etc&#x2F;sysctl.conf\ncd /etcsudo vim sysctl.conf\n\n\n编辑sysctl.conf\n\nvm.swappiness=10\n\n调整缓存设置增大vfs_cache_pressure的值会让系统倾向于删除缓存中inode和dentry信息，进而导致系统频繁访问文件系统，我们可以通过输入以下内容将其设置为更保守的设置，例如50：\n只在当前会话生效sudo sysctl vm.vfs_cache_pressure=50\n\n永久修改(推荐)&#x2F;etc&#x2F;sysctl.conf\ncd /etcsudo vim sysctl.conf\n\n\n添加以下配置\n\nvm.vfs_cache_pressure=50","categories":["Linux","ubuntu"],"tags":["Linux","ubuntu","swap分区"]},{"title":"前端白屏检测","url":"/2023/01/06/%E5%89%8D%E7%AB%AF%E7%99%BD%E5%B1%8F%E6%A3%80%E6%B5%8B/","content":"白屏检测的不确定性\n当白屏发生的时候，无法和具体的某个报错进行直接的联系，或者说根本就没有抛出异常\n导致白屏的原因：\n资源加载错误\n程序执行异常\n\n\n其次就是前端渲染的多样性，前端页面渲染的方式有多种\n客户端渲染CSR\n服务端渲染SSR\n静态页面生成SSG\n\n\n\n检测方案检测根节点是否渲染\n在当前主流的SPA框架下，页面的dom树一般都会挂载在某个根节点下，所以采用对根节点进行检测来验证白屏的原因。这种情况下发生白屏后通常是根节点下所有的dom被卸载，如果根节点下的dom没有被卸载，则无法证明是该原因照成的白屏。\n\nMutation Observer 监听 DOM 变化通过此 API 监听页面 DOM 变化，并告诉我们每次变化的 DOM 是被增加还是删除\n页面截图检测这种方式是基于原生图片对比算法处理白屏检测的 web 实现\n整体流程：对页面进行截图，将截图与一张纯白的图片做对比，判断两者是否足够相似\n\n缺陷\n1、方案较为复杂，性能不高；一方面需要借助 canvas 实现前端截屏，同时需要借助复杂的算法对图片进行对比\n2、通用性较差，对于有骨架屏的项目，对比的样张要由纯白的图片替换成骨架屏的截图\n\n采样对比\n该方法是对页面取关键点，进行采样对比，在准确性、易用性等方面均表现良好，也是最终采用的方案\n对于有骨架屏的项目，通过对比前后获取的 dom 元素是否一致，来判断页面是否变化\n\n// 监听页面白屏function whiteScreen() &#123;  // 页面加载完毕  function onload(callback) &#123;    // 检测dom加载状态        /*         loading（正在加载）:document 仍在加载。        interactive（可交互）:文档已被解析，&quot;正在加载&quot;状态结束，但是诸如图像，样式表和框架之类的子资源仍在加载。        complete（完成）:文档和所有子资源已完成加载。表示 load 状态的事件即将被触发。      */    if (document.readyState === &#x27;complete&#x27;) &#123;      callback();    &#125; else &#123;      window.addEventListener(&#x27;load&#x27;, callback);    &#125;  &#125;  // 定义外层容器元素的集合  let containerElements = [&#x27;html&#x27;, &#x27;body&#x27;, &#x27;#app&#x27;, &#x27;#root&#x27;];  // 容器元素个数  let emptyPoints = 0;  // 选中dom的名称  function getSelector(element) &#123;    if (element.id) &#123;      return &quot;#&quot; + element.id;    &#125; else if (element.className) &#123;// div home =&gt; div.home      return &quot;.&quot; + element.className.split(&#x27; &#x27;).filter(item =&gt; !!item).join(&#x27;.&#x27;);    &#125; else &#123;      return element.nodeName.toLowerCase();    &#125;  &#125;  // 是否为容器节点  function isContainer(element) &#123;    let selector = getSelector(element);    if (containerElements.indexOf(selector) != -1) &#123;      emptyPoints++;    &#125;  &#125;  onload(() =&gt; &#123;    // 页面加载完毕初始化    for (let i = 1; i &lt;= 9; i++) &#123;        // 对页面取关键点坐标      let xElements = document.elementsFromPoint(window.innerWidth * i / 10, window.innerHeight / 2);      let yElements = document.elementsFromPoint(window.innerWidth / 2, window.innerHeight * i / 10);      // 检测是否为容器节点      isContainer(xElements[0]);      // 中心点只计算一次      if (i != 5) &#123;        isContainer(yElements[0]);      &#125;    &#125;    // 17个点都是容器节点算作白屏    if (emptyPoints == 17) &#123;      // 获取白屏信息      console.log(&#123;        status: &#x27;error&#x27;      &#125;);    &#125;  &#125;&#125;\n\n骨架屏的白屏检测\n上面的白屏检测方案对有骨架屏的项目失灵了，虽然页面一直显示骨架屏，但判断结果页面不是白屏，不符合我们的预期\n需要通过外部传参明确的告诉 SDK，该页面是不是有骨架屏，如果有骨架屏，通过对比前后获取的 dom 元素是否一致，来实现骨架屏的白屏检测\n\n/** * 检测页面是否白屏 * @param &#123;function&#125; callback - 回到函数获取检测结果 * @param &#123;boolean&#125; skeletonProject - 页面是否有骨架屏 * @param &#123;array&#125; whiteBoxElements - 容器列表，默认值为[&#x27;html&#x27;, &#x27;body&#x27;, &#x27;#app&#x27;, &#x27;#root&#x27;] */export function openWhiteScreen(callback, &#123; skeletonProject, whiteBoxElements &#125;) &#123;  let _whiteLoopNum = 0;  let _skeletonInitList = []; // 存储初次采样点  let _skeletonNowList = []; // 存储当前采样点  // 项目有骨架屏  if (skeletonProject) &#123;    if (document.readyState != &#x27;complete&#x27;) &#123;      sampling();    &#125;  &#125; else &#123;    // 页面加载完毕    if (document.readyState === &#x27;complete&#x27;) &#123;      sampling();    &#125; else &#123;      window.addEventListener(&#x27;load&#x27;, sampling);    &#125;  &#125;  // 选中dom点的名称  function getSelector(element) &#123;    if (element.id) &#123;      return &#x27;#&#x27; + element.id;    &#125; else if (element.className) &#123;      // div home =&gt; div.home      return (&#x27;.&#x27; + element.className.split(&#x27; &#x27;).filter(item =&gt; !!item).join(&#x27;.&#x27;));    &#125; else &#123;      return element.nodeName.toLowerCase();    &#125;  &#125;  // 判断采样点是否为容器节点  function isContainer(element) &#123;    let selector = getSelector(element);    if (skeletonProject) &#123;      _whiteLoopNum ? _skeletonNowList.push(selector) : _skeletonInitList.push(selector);    &#125;    return whiteBoxElements.indexOf(selector) != -1;  &#125;  // 采样对比  function sampling() &#123;    let emptyPoints = 0;    for (let i = 1; i &lt;= 9; i++) &#123;      let xElements = document.elementsFromPoint(        (window.innerWidth * i) / 10,        window.innerHeight / 2      );      let yElements = document.elementsFromPoint(        window.innerWidth / 2,        (window.innerHeight * i) / 10      );      if (isContainer(xElements[0])) emptyPoints++;      // 中心点只计算一次      if (i != 5) &#123;        if (isContainer(yElements[0])) emptyPoints++;      &#125;    &#125;    // 页面正常渲染，停止轮训    if (emptyPoints != 17) &#123;      if (skeletonProject) &#123;        // 第一次不比较        if (!_whiteLoopNum) return openWhiteLoop();        // 比较前后dom是否一致        if (_skeletonNowList.join() == _skeletonInitList.join())          return callback(&#123;            status: &#x27;error&#x27;          &#125;);      &#125;      if (window._loopTimer) &#123;        clearTimeout(window._loopTimer);        window._loopTimer = null;      &#125;    &#125; else &#123;      // 开启轮训      if (!window._loopTimer) &#123;        openWhiteLoop();      &#125;    &#125;    // 17个点都是容器节点算作白屏    callback(&#123;      status: emptyPoints == 17 ? &#x27;error&#x27; : &#x27;ok&#x27;,    &#125;);  &#125;  // 开启白屏轮训  function openWhiteLoop() &#123;    if (window._loopTimer) return;    window._loopTimer = setInterval(() =&gt; &#123;      if (skeletonProject) &#123;        _whiteLoopNum++;        _skeletonNowList = [];      &#125;      sampling();    &#125;, 1000);  &#125;&#125;\n","categories":["前端","优化"],"tags":["前端","Vue","前端优化","白屏检测"]}]